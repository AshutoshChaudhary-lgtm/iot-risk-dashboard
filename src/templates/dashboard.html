<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>IoT Risk Dashboard</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" />
    <!-- Axios for API calls -->
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
    <style>
      #map {
        height: 400px;
        margin-bottom: 30px;
      }
      .risk-badge {
        font-size: 1em;
      }
      .detail-row {
        display: none;
        background-color: #f8f9fa;
      }
      .clickable-row {
        cursor: pointer;
      }
      .device-detail {
        padding: 15px;
      }
      .vulnerability-item {
        margin-bottom: 8px;
        padding: 8px;
        border-radius: 4px;
      }
      .vulnerability-critical {
        background-color: #ffebee;
      }
      .vulnerability-high {
        background-color: #fff8e1;
      }
      .vulnerability-medium {
        background-color: #e8f5e9;
      }
      .vulnerability-low {
        background-color: #e3f2fd;
      }
    </style>
  </head>
  <body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
      <div class="container-fluid">
        <a class="navbar-brand" href="#">IoT Risk Dashboard</a>
        <div class="collapse navbar-collapse">
        </div>
      </div>
    </nav>
    <div class="container mt-4">
      <div class="row">
        <div class="col-md-8">
          <h1>IoT Risk Dashboard</h1>
          <p>Scan for IoT devices using Shodan and view risk assessments in real-time.</p>
        </div>
        <div class="col-md-4">
          <div class="card">
            <div class="card-body">
              <h5 class="card-title">Quick Search</h5>
              <p class="card-text">Enter an IP address, range, or Shodan query</p>
              <div class="input-group mb-3">
                <input type="text" id="ipRangeInput" class="form-control" 
                  placeholder="IP, range, or 'port:22 country:US'" />
                <button id="scanBtn" class="btn btn-primary">Scan</button>
              </div>
              <div class="form-text">Examples: 8.8.8.8, port:22 country:US, webcam</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Error alert -->
      <div id="errorAlert" class="alert alert-danger d-none" role="alert"></div>
      <!-- Warning alert -->
      <div id="warningAlert" class="alert alert-warning d-none" role="alert"></div>
      <!-- Loading spinner -->
      <div id="loadingSpinner" class="d-none my-4 text-center">
        <div class="spinner-border text-primary" role="status"><span class="visually-hidden">Loading...</span></div>
        <p class="mt-2">Searching for devices... This may take a moment.</p>
      </div>

      <!-- Map Container -->
      <div id="mapSection" class="mb-4">
        <h2>Device Map</h2>
        <div id="map"></div>
      </div>

      <!-- Devices Table -->
      <div id="devicesSection">
        <div class="d-flex justify-content-between align-items-center">
          <h2>Devices</h2>
          <span id="deviceCount" class="badge bg-primary">0</span>
        </div>
        <div class="table-responsive">
          <table class="table table-striped table-hover">
            <thead>
              <tr>
                <th>IP</th>
                <th>Country/City</th>
                <th>OS</th>
                <th>Ports</th>
                <th>Risk Score</th>
              </tr>
            </thead>
            <tbody id="devicesTableBody"></tbody>
          </table>
        </div>
      </div>
    </div>
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
    <script>
      // Initialize Leaflet map
      const map = L.map('map').setView([20, 0], 2); // World view
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
      }).addTo(map);

      // Clear existing markers when scanning new data
      let markersLayer = L.layerGroup().addTo(map);

      document.getElementById('scanBtn').addEventListener('click', function() {
        scanDevices();
      });

      // Allow pressing Enter in the input field to trigger the scan
      document.getElementById('ipRangeInput').addEventListener('keypress', function(event) {
        if (event.key === 'Enter') {
          scanDevices();
        }
      });

      function scanDevices() {
        const ipRange = document.getElementById('ipRangeInput').value;
        if (!ipRange) {
          showError("Please enter an IP address, range, or search query");
          return;
        }
        
        // Reset UI elements
        resetUI();
        
        // Show loading spinner
        document.getElementById('loadingSpinner').classList.remove('d-none');

        axios.get('/devices', { params: { ip_range: ipRange } })
          .then((response) => {
            // Remove loading spinner
            document.getElementById('loadingSpinner').classList.add('d-none');
            console.log("API response:", response.data);

            const devices = response.data.devices || [];
            const risks = response.data.risks || [];
            
            // Show warning if present
            if (response.data.warning) {
              const warningAlert = document.getElementById('warningAlert');
              warningAlert.classList.remove('d-none');
              warningAlert.innerText = response.data.warning;
            }

            // Update device count
            document.getElementById('deviceCount').textContent = devices.length;
            
            if (devices.length === 0) {
              // No results found
              showWarning("No devices found for your query.");
              return;
            }
            
            // Populate table
            populateDevicesTable(devices, risks);
            
            // Add markers to map
            addDeviceMarkers(devices);
          })
          .catch((error) => {
            // Remove loading spinner and show error message
            document.getElementById('loadingSpinner').classList.add('d-none');
            if (error.response && error.response.data && error.response.data.detail) {
              showError(`Error: ${error.response.data.detail}`);
            } else if (error.response && error.response.data && error.response.data.error) {
              showError(`Error: ${error.response.data.error}`);
            } else {
              showError('Error scanning devices. Check your connection and try again.');
            }
            console.error(error);
          });
      }

      function resetUI() {
        // Clear previous results
        document.getElementById('errorAlert').classList.add('d-none');
        document.getElementById('warningAlert').classList.add('d-none');
        document.getElementById('devicesTableBody').innerHTML = '';
        markersLayer.clearLayers();
      }

      function showError(message) {
        const errorAlert = document.getElementById('errorAlert');
        errorAlert.classList.remove('d-none');
        errorAlert.innerText = message;
      }

      function showWarning(message) {
        const warningAlert = document.getElementById('warningAlert');
        warningAlert.classList.remove('d-none');
        warningAlert.innerText = message;
      }

      function populateDevicesTable(devices, risks) {
        const tableBody = document.getElementById('devicesTableBody');
        tableBody.innerHTML = '';
        
        devices.forEach((device, index) => {
          // Find the risk data for this device
          const risk = risks[index] || {};
          const riskScore = risk.risk_score || 'N/A';
          
          // Format ports as a comma-separated list
          const ports = device.ports?.join(', ') || 'N/A';
          
          // IMPROVED LOCATION HANDLING
          // First check location object, then check root level properties
          let countryName = 'N/A';
          let cityName = 'N/A';
          
          // Try to get location from both possible locations in the API response
          if (device.location) {
            countryName = device.location.country_name || countryName;
            cityName = device.location.city || cityName;
          }
          
          // Also check if location data is at the root level
          if (device.country_name) countryName = device.country_name;
          if (device.city) cityName = device.city;
          
          console.log('Device data:', {
            ip: device.ip_str,
            location: device.location,
            country: countryName,
            city: cityName,
            latitude: device.location?.latitude || device.latitude,
            longitude: device.location?.longitude || device.longitude
          });
          
          // Create the main device row
          const row = document.createElement('tr');
          row.className = 'clickable-row';
          row.dataset.deviceId = index;
          
          row.innerHTML = `
            <td>${device.ip_str || 'N/A'}</td>
            <td>${countryName} / ${cityName}</td>
            <td>${device.os || 'Unknown'}</td>
            <td>${ports}</td>
            <td><span class="badge ${getRiskBadgeClass(riskScore)}">${riskScore}</span></td>
          `;
          tableBody.appendChild(row);
          
          // Create the detail row
          const detailRow = document.createElement('tr');
          detailRow.className = 'detail-row';
          detailRow.id = `detail-${index}`;
          
          // Create detail content
          const hostnames = device.hostnames?.join(', ') || 'None';
          const domains = device.domains?.join(', ') || 'None';
          
          // Get vulnerabilities from device or risk data
          const vulns = device.vulns || {};
          const vulnList = Object.entries(vulns).map(([id, info]) => {
            return {
              id,
              ...info,
              severity: info.severity || 'unknown'
            };
          });
          
          // Format vulnerability display
          let vulnHtml = '<p>No known vulnerabilities</p>';
          if (vulnList.length > 0) {
            vulnHtml = '<div class="vulnerabilities-list">';
            vulnList.forEach(vuln => {
              const vulnClass = `vulnerability-${vuln.severity.toLowerCase()}`;
              vulnHtml += `
                <div class="vulnerability-item ${vulnClass}">
                  <strong>${vuln.id}</strong> 
                  <span class="badge bg-${getSeverityBadgeClass(vuln.severity)}">${vuln.severity}</span>
                  <div>${vuln.summary || 'No details available'}</div>
                </div>
              `;
            });
            vulnHtml += '</div>';
          }
          
          // Services list
          const services = risk.services || [];
          const servicesHtml = services.length ? 
            services.map(s => `<span class="badge bg-info me-1">${s}</span>`).join(' ') : 
            'No service information';
          
          detailRow.innerHTML = `
            <td colspan="5">
              <div class="device-detail">
                <div class="row">
                  <div class="col-md-6">
                    <h5>Device Information</h5>
                    <p><strong>Hostnames:</strong> ${hostnames}</p>
                    <p><strong>Domains:</strong> ${domains}</p>
                    <p><strong>Services:</strong> ${servicesHtml}</p>
                  </div>
                  <div class="col-md-6">
                    <h5>Vulnerabilities</h5>
                    ${vulnHtml}
                  </div>
                </div>
              </div>
            </td>
          `;
          tableBody.appendChild(detailRow);
          
          // Add click event to show/hide details
          row.addEventListener('click', function() {
            const detailElement = document.getElementById(`detail-${this.dataset.deviceId}`);
            const allDetails = document.querySelectorAll('.detail-row');
            
            // Hide all other details
            allDetails.forEach(el => {
              if (el !== detailElement) {
                el.style.display = 'none';
              }
            });
            
            // Toggle current detail
            detailElement.style.display = detailElement.style.display === 'table-row' ? 'none' : 'table-row';
          });
        });
      }
      
      function getRiskBadgeClass(score) {
        if (score === 'N/A') return 'bg-secondary';
        if (score > 75) return 'bg-danger';
        if (score > 50) return 'bg-warning';
        if (score > 25) return 'bg-info';
        return 'bg-success';
      }
      
      function getSeverityBadgeClass(severity) {
        const sev = severity.toLowerCase();
        if (sev === 'critical') return 'danger';
        if (sev === 'high') return 'warning text-dark';
        if (sev === 'medium') return 'info text-dark';
        return 'success';
      }
      
      function addDeviceMarkers(devices) {
        // Clear previous markers
        markersLayer.clearLayers();
        console.log(`Processing ${devices.length} devices for map markers`);
        
        let markerCount = 0;
        
        // Add markers for each device with location data
        devices.forEach((device, index) => {
          // Try to get latitude and longitude from both possible locations
          let lat, lng;
          
          // First check the location object
          if (device.location) {
            lat = device.location.latitude;
            lng = device.location.longitude;
          }
          
          // If not found, check root level properties
          if (!lat || !lng) {
            lat = device.latitude;
            lng = device.longitude;
          }
          
          // Get country and city similar to how we do in the table
          let countryName = 'Unknown';
          let cityName = 'Unknown';
          
          if (device.location) {
            countryName = device.location.country_name || countryName;
            cityName = device.location.city || cityName;
          }
          
          if (device.country_name) countryName = device.country_name;
          if (device.city) cityName = device.city;
          
          console.log(`Device ${index+1}: ${device.ip_str}, Location: [${lat}, ${lng}], Country: ${countryName}, City: ${cityName}`);
          
          // Only create marker if we have valid coordinates
          if (lat && lng && !isNaN(lat) && !isNaN(lng)) {
            // Convert strings to numbers if needed
            const latNum = typeof lat === 'string' ? parseFloat(lat) : lat;
            const lngNum = typeof lng === 'string' ? parseFloat(lng) : lng;
            
            // Skip invalid coordinates
            if (isNaN(latNum) || isNaN(lngNum)) {
              console.log(`Skipping invalid coordinates for ${device.ip_str}: [${lat}, ${lng}]`);
              return;
            }
            
            // Skip devices with no location
            const marker = L.marker([latNum, lngNum]).addTo(markersLayer);
            markerCount++;
            
            // Create popup content
            const riskLevel = getRiskLevel(device);
            const popupContent = `
              <strong>IP:</strong> ${device.ip_str || 'Unknown'}<br>
              <strong>Country:</strong> ${countryName}<br>
              <strong>City:</strong> ${cityName}<br>
              <strong>OS:</strong> ${device.os || 'Unknown'}<br>
              <strong>Risk:</strong> <span class="risk-level risk-${riskLevel.toLowerCase()}">${riskLevel}</span>
            `;
            
            marker.bindPopup(popupContent);
          } else {
            console.log(`No valid coordinates for device ${device.ip_str}`);
          }
        });
        
        console.log(`Added ${markerCount} markers to the map`);
        
        // Adjust map view to show all markers if there are any
        if (markersLayer.getLayers().length > 0) {
          const group = L.featureGroup(markersLayer.getLayers());
          map.fitBounds(group.getBounds(), { padding: [50, 50] });
        } else {
          console.log('No markers to display on map');
          // If no markers, show a warning
          showWarning("No devices with location data found to display on map.");
        }
      }
      
      function getRiskLevel(device) {
        // Simplified risk level estimation based on open ports
        const numPorts = device.ports?.length || 0;
        const hasVulns = device.vulns && Object.keys(device.vulns).length > 0;
        
        if (hasVulns) return 'High';
        if (numPorts > 5) return 'Medium';
        return 'Low';
      }
    </script>
  </body>
</html>